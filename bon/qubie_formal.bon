static_diagram QUBIE_TOPLEVEL
component 
	cluster MAIN
	component 
	    class QUBIE_STATUS
	    inherit VALUE
	    invariant
	      Current member_of {booting, running, stopped}
	    end
		class QUBIE
		feature
			--the following booleans represent possible qubie states
			booting : BOOLEAN 
			  ensure Result = (status = booting) end
			running : BOOLEAN 
			  ensure Result = (status = running) end
			stopped : BOOLEAN --qubie has run and stopped
			  ensure Result = (status = stopped) end
			status : QUBIE_STATUS
			
			observations : OBSERVATIONS
				require not booting end	
			wifi_monitor : WIFI_MONITOR
				require not booting end
			bt_communicator : BLUETOOTH_COMMUNICATOR
				require not booting end
			log : LOG
				require 
				  not booting --TODO? is this require needed if the log is constructed as part of the constructor?
				end
			start_running -- : Void 
				require
					booting
				ensure
					running;
					log.logged(Current);
				end
			stop_running 
				require running
				ensure
					stopped;
					log.logged(Current);
				end
			update_status	--mapping to allow external acces to change states
				-> the_status : QUBIE_STATUS
				require
					the_status member_of {running, stopped};  --for now don't allow any external input to change the status to booting
				ensure
					(the_status = running) -> start_running;
					(the_status = stopped) -> stop_running;
				end
			record_observation 
				-> contact_record : CONTACT_RECORD
				ensure 
					delta {observations, log}; --if observations is a sequence/list we could limit to observations(size)
					observations.contains(contact_record);
					log.logged(Current);
				end
			initialized --TODO get consensus on syntax
				ensure 
					log.empty;
					observations.empty;
				end
--		constraint
--			old(stopped) implies stopped	
		end	
	end
end


static_diagram QUBIE_WIFI_MONITOR
component
	class WIFI_MONITOR
	feature 
		booting : BOOLEAN
		running : BOOLEAN
		auto_hopping : BOOLEAN
		keyed_hash : KEYED_HASH
		frequency_range : SET[FREQUENCY]
		frequency : FREQUENCY
		qubie : QUBIE
		
		start
			require
				keyed_hash.set;
				not booting;
				not running
			ensure
				--delta {Current, qubie.observations, qubie.log};
				running;
				qubie.log.logged(Current)
			end
		stop 
			require
				running;
			ensure
				not running; 
				qubie.log.logged(Current);
			end
		set_frequency 
			-> the_frequency : FREQUENCY
			ensure 
				delta {frequency, qubie.log};
				frequency=the_frequency; 
				qubie.log.logged(Current);	
			end
		set_auto_hopping 
			-> the_truth_value : BOOLEAN
			ensure 
				delta {auto_hopping, qubie.log};
				auto_hopping=the_truth_value; 
				qubie.log.logged(Current);	
			end
		report_detected_device
			-> the_mac_address : VALUE
			-> the_signal_strength : VALUE
			ensure
				delta {qubie.observations, qubie.log};
				qubie.observations.contains(CONTACT_RECORD.make(keyed_hash, the_mac_address, the_signal_strength));
				qubie.log.logged(Current);	
			end
		--TODO the keyed hash is never changed after running
	end

	class FREQUENCY
	inherit VALUE
	end
end
	


static_diagram QUBIE_BLUETOOTH_COMMUNICATOR
component
	class BLUETOOTH_COMMUNICATOR
	feature
		qubie : QUBIE
		--qubie_status is taken from qubie internal fields
		subscribed : BOOLEAN
		bt_client : BLUETOOTH_CLIENT
		
		subscribe
			-> the_bluetooth_client : BLUETOOTH_CLIENT
			require
				not subscribed;
			ensure
				delta {bit_client, subscribed};
				bt_client=the_bluetooth_client;
				subscribed;
			end
		unsubscribe
			require
				subscribed;
			ensure
				delta {bit_client, subscribed};
				not subscribed;
			end
		update_qubie_status
			-> the_status : VALUE
			require
				the_status = stopped; --for now the only legal command is to stop running
			ensure 
				qubie.update_status(the_status); 
			end
	end
	class BLUETOOTH_CLIENT
end	


static_diagram WIFI_DEVICE_IDENTIFIER
component
	class DEVICE_IDENTIFIER --immutable
	feature
		encrypted : BOOLEAN
		identifier_string : STRING
	end
end
	
	
static_diagram QUBIE_KEYED_HASH
component
	class HASH reused
	class KEYED_HASH
	feature
		set : BOOLEAN --write-once
		set_key
			-> the_key : VALUE
			require
				not set
			ensure
				delta {set, key};
				key=the_key;
				set
			end
		hashed_string : VALUE
			->the_string : STRING
			require set
			ensure
				Result=hash.hash(the_string)
				--Return the keyed hash of the string
			end
--	constraint
--		old.set implies set
	--invariant
		--for_all a,b:STRING it_holds ((hashed_string(a)=hashed_string(b))=(a=b) )
		--exists a:STRING such_that (a /= hashed_string(a))
--	end
--	feature NONE
		key : VALUE --write-once
		hash : HASH --we know that hash is functional
	end
end
	
static_diagram QUBIE_CONTACT_RECORDINGS
component
	class TIME reused
	class CONTACT_RECORD --immutable
	feature
		device_id : DEVICE_IDENTIFIER
		contact_time : TIME
		rssi : VALUE
		frequency : FREQUNCY
	end
	class OBSERVATIONS inherit SET[CONTACT_RECORD] end --TODO make this a sequence, or perhaps list
end


static_diagram QUBIE_LOGGER
component 
	class LOG_ENTRY --immutable
	feature
		message : STRING
		time : STRING
	end
	class LOG persistent
	inherit LIST[LOG_ENTRY] 
	feature
--		entry++ : LOG_ENTRY {^LIST.element} --rename element as entry
		logged
			-> entry : OBJECT
			ensure
				delta element(size);
				contains(LOG_ENTRY.make(entry));
				--Result=True
			end
	--constraint
	--	for_all i:[1..old.size] it_holds old element(i)=element(i)
	end
end
	
	
	



	
	